#include "TensorTypes.h"


// -------------------- Coordinates --------------------
template<class Coord>
Coordinate2<Coord>::Coordinate2(double value)
{
    data[0] = data[1] = value;
}
template<class Coord>
Coordinate2<Coord>::Coordinate2(double data1, double data2)
{
    data[0] = data1;
    data[1] = data2;
}
template<class Coord>
template<class CoordB>
Coordinate2<CoordB> Coordinate2<Coord>::Transform() const
{
    if constexpr(std::is_same<Coord,xy>::value && std::is_same<CoordB,rph>::value)
        return Coordinate2<CoordB>(sqrt(data[0]*data[0] + data[1]*data[1]), fmod(atan2(data[1],data[0]) + 2.0*M_PI, 2.0*M_PI));
    if constexpr(std::is_same<Coord,rph>::value && std::is_same<CoordB,xy>::value)
        return Coordinate2<CoordB>(data[0]*cos(data[1]), data[0]*sin(data[1]));
    if constexpr(std::is_same<Coord,CoordB>::value)
        return Coordinate2<CoordB>(data[0], data[1]);
}
template<class Coord>
void Coordinate2<Coord>::Print(std::string name, bool newline, int precision) const
{
    std::cout << name << " = ("
	<< Format(data[0],precision) << ","
	<< Format(data[1],precision) << ")"
	<< std::endl;
    if(newline)
        std::cout << std::endl;
}
template<class Coord>
double& Coordinate2<Coord>::operator[](const int index)
{
    return data[index-1];
}
template<class Coord>
const double& Coordinate2<Coord>::operator[](const int index) const
{
    return data[index-1];
}
// -----------------------------------------------------

// -------------------- Rank-1 Tensors --------------------
template<class Coord, class Frame>
Tensor2<Coord,Frame>::Tensor2(double value)
{
    data[0] = data[1] = value;
}
template<class Coord, class Frame>
Tensor2<Coord,Frame>::Tensor2(double data1, double data2)
{
    data[0] = data1;
    data[1] = data2;
}
template<class Coord, class Frame>
template<class CoordB>
Tensor2<CoordB,Frame> Tensor2<Coord,Frame>::Transform(const Coordinate2<Coord>& x12) const
{
    if constexpr(std::is_same<Coord,xy>::value && std::is_same<CoordB,rph>::value)
    {// x12 = xy;
        double r = sqrt(x12[1]*x12[1] + x12[2]*x12[2]);
        return Tensor2<CoordB,Frame>(x12[1]/r*data[0] + x12[2]/r*data[1], -x12[2]/(r*r)*data[0] + x12[1]/(r*r)*data[1]);
    }
    if constexpr(std::is_same<Coord,rph>::value && std::is_same<CoordB,xy>::value)
    {// x12 = rph;
        return Tensor2<CoordB,Frame>(cos(x12[2])*data[0] - x12[1]*sin(x12[2])*data[1], sin(x12[2])*data[0] + x12[1]*cos(x12[2])*data[1]);
    }
    if constexpr(std::is_same<Coord,CoordB>::value)
        return Tensor2<CoordB,Frame>(data[0], data[1]);
}
template<class Coord, class Frame>
template<class FrameB>
Tensor2<Coord,FrameB> Tensor2<Coord,Frame>::Transform(Tensor3x3<Coord,Tetrad>& tetrad) const
{
    if constexpr(std::is_same<Frame,IF>::value && std::is_same<FrameB,LF>::value)
    {// IF -> LF
        return Tensor2<Coord,FrameB>(tetrad[{1,1}]*data[0] + tetrad[{1,2}]*data[1], tetrad[{2,1}]*data[0] + tetrad[{2,2}]*data[1]);
    }
    if constexpr(std::is_same<Frame,LF>::value && std::is_same<FrameB,IF>::value)
    {// LF -> IF
        Tensor3x3<Coord,Tetrad> tetradInverse = tetrad.Invert();
        return Tensor2<Coord,FrameB>(tetradInverse[{1,1}]*data[0] + tetradInverse[{1,2}]*data[1], tetradInverse[{2,1}]*data[0] + tetradInverse[{2,2}]*data[1]);
    }
}
template<class Coord, class Frame>
template<class FrameB>
Tensor2<Coord,FrameB> Tensor2<Coord,Frame>::Transform(Tensor3x3<Coord,Tetrad>&& tetrad) const
{
    if constexpr(std::is_same<Frame,IF>::value && std::is_same<FrameB,LF>::value)
    {// IF -> LF
        return Tensor2<Coord,FrameB>(tetrad[{1,1}]*data[0] + tetrad[{1,2}]*data[1], tetrad[{2,1}]*data[0] + tetrad[{2,2}]*data[1]);
    }
    if constexpr(std::is_same<Frame,LF>::value && std::is_same<FrameB,IF>::value)
    {// LF -> IF
        Tensor3x3<Coord,Tetrad> tetradInverse = tetrad.Invert();
        return Tensor2<Coord,FrameB>(tetradInverse[{1,1}]*data[0] + tetradInverse[{1,2}]*data[1], tetradInverse[{2,1}]*data[0] + tetradInverse[{2,2}]*data[1]);
    }
}
template<class Coord, class Frame>
double Tensor2<Coord,Frame>::Norm(const Tensor2x2<Coord,Frame>& metric2_ll) const
{
    double norm = 0;
    for(int j=1; j<3; j++)
    for(int i=1; i<3; i++)
        norm += metric2_ll[{i,j}]*(*this)[i]*(*this)[j];
    return sqrt(abs(norm));
}
template<class Coord, class Frame>
double Tensor2<Coord,Frame>::EuklNorm() const
{
    double norm = data[0]*data[0] + data[1]*data[1];
    return sqrt(norm);
}
template<class Coord, class Frame>
double Tensor2<Coord,Frame>::Angle() const
{
    // transform [-pi,pi] output of atan2 to [0,2pi]:
    return std::fmod(atan2(data[1],data[0])+2*M_PI, 2*M_PI);
}
template<class Coord, class Frame>
void Tensor2<Coord,Frame>::Print(std::string name, bool newline, int precision) const
{
    std::cout << name;
    if constexpr(std::is_same<Frame,IF>::value)
    {
        std::cout << "(IF)" << " = ("
	    << Format(data[0],precision) << ","
	    << Format(data[1],precision) << ")"
	    << std::endl;
    }
    if constexpr(std::is_same<Frame,LF>::value)
    {
        std::cout << "(LF)" << " = ("
	    << Format(data[0],precision) << ","
	    << Format(data[1],precision) << ")"
	    << std::endl;
    }
    if(newline)
        std::cout << std::endl;
}
template<class Coord, class Frame>
double& Tensor2<Coord,Frame>::operator[](const int index)
{
    return data[index-1];
}
template<class Coord, class Frame>
const double& Tensor2<Coord,Frame>::operator[](const int index) const
{
    return data[index-1];
}



template<class Coord, class Frame>
Tensor3<Coord,Frame>::Tensor3(double value)
{
    data[0] = data[1] = data[2] = value;
}
template<class Coord, class Frame>
Tensor3<Coord,Frame>::Tensor3(double data0, double data1, double data2)
{
    data[0] = data0;
    data[1] = data1;
    data[2] = data2;
}
template<class Coord, class Frame>
template<class CoordB>
Tensor3<CoordB,Frame> Tensor3<Coord,Frame>::Transform(const Coordinate2<Coord>& x12) const
{
    if constexpr(std::is_same<Coord,xy>::value && std::is_same<CoordB,rph>::value)
    {// x12 = xy;
        double r = sqrt(x12[1]*x12[1] + x12[2]*x12[2]);
        return Tensor3<CoordB,Frame>(data[0], x12[1]/r*data[1] + x12[2]/r*data[2], -x12[2]/(r*r)*data[1] + x12[1]/(r*r)*data[2]);
    }
    if constexpr(std::is_same<Coord,rph>::value && std::is_same<CoordB,xy>::value)
    {// x12 = rph;
        return Tensor3<CoordB,Frame>(data[0], cos(x12[2])*data[1] - x12[1]*sin(x12[2])*data[2], sin(x12[2])*data[1] + x12[1]*cos(x12[2])*data[2]);
    }
    if constexpr(std::is_same<Coord,CoordB>::value)
        return Tensor3<CoordB,Frame>(data[0], data[1], data[2]);
}
template<class Coord, class Frame>
template<class FrameB>
Tensor3<Coord,FrameB> Tensor3<Coord,Frame>::Transform(Tensor3x3<Coord,Tetrad>& tetrad) const
{
    if constexpr(std::is_same<Frame,IF>::value && std::is_same<FrameB,LF>::value)
    {// IF -> LF
        return Tensor3<Coord,FrameB>
        (tetrad[{0,0}]*data[0] + tetrad[{0,1}]*data[1] + tetrad[{0,2}]*data[2],
         tetrad[{1,0}]*data[0] + tetrad[{1,1}]*data[1] + tetrad[{1,2}]*data[2],
         tetrad[{2,0}]*data[0] + tetrad[{2,1}]*data[1] + tetrad[{2,2}]*data[2]);
    }
    if constexpr(std::is_same<Frame,LF>::value && std::is_same<FrameB,IF>::value)
    {// LF -> IF
        Tensor3x3<Coord,Tetrad> tetradInverse = tetrad.Invert();
        return Tensor3<Coord,FrameB>
        (tetradInverse[{0,0}]*data[0] + tetradInverse[{0,1}]*data[1] + tetradInverse[{0,2}]*data[2],
         tetradInverse[{1,0}]*data[0] + tetradInverse[{1,1}]*data[1] + tetradInverse[{1,2}]*data[2],
         tetradInverse[{2,0}]*data[0] + tetradInverse[{2,1}]*data[1] + tetradInverse[{2,2}]*data[2]);
    }
}
template<class Coord, class Frame>
template<class FrameB>
Tensor3<Coord,FrameB> Tensor3<Coord,Frame>::Transform(Tensor3x3<Coord,Tetrad>&& tetrad) const
{
    if constexpr(std::is_same<Frame,IF>::value && std::is_same<FrameB,LF>::value)
    {// IF -> LF
        return Tensor3<Coord,FrameB>
        (tetrad[{0,0}]*data[0] + tetrad[{0,1}]*data[1] + tetrad[{0,2}]*data[2],
         tetrad[{1,0}]*data[0] + tetrad[{1,1}]*data[1] + tetrad[{1,2}]*data[2],
         tetrad[{2,0}]*data[0] + tetrad[{2,1}]*data[1] + tetrad[{2,2}]*data[2]);
    }
    if constexpr(std::is_same<Frame,LF>::value && std::is_same<FrameB,IF>::value)
    {// LF -> IF
        Tensor3x3<Coord,Tetrad> tetradInverse = tetrad.Invert();
        return Tensor3<Coord,FrameB>
        (tetradInverse[{0,0}]*data[0] + tetradInverse[{0,1}]*data[1] + tetradInverse[{0,2}]*data[2],
         tetradInverse[{1,0}]*data[0] + tetradInverse[{1,1}]*data[1] + tetradInverse[{1,2}]*data[2],
         tetradInverse[{2,0}]*data[0] + tetradInverse[{2,1}]*data[1] + tetradInverse[{2,2}]*data[2]);
    }
}
template<class Coord, class Frame>
void Tensor3<Coord,Frame>::NullNormalize(const Tensor3x3<Coord,Frame>& metric3_ll)
{
    double a = 0;
    for(int i=1; i<3; i++)
    for(int j=1; j<3; j++)
        a += metric3_ll[{i,j}]*data[i]*data[j];
    double b = 0;
    for(int i=1; i<3; i++)
        b += metric3_ll[{0,i}]*data[0]*data[i];
    double c = metric3_ll[{0,0}]*data[0]*data[0];
    double d = -b/a + sqrt( (b*b)/(a*a) - c/a );
    data[1] *= d;
    data[2] *= d;
}
template<class Coord, class Frame>
double Tensor3<Coord,Frame>::Norm(const Tensor3x3<Coord,Frame>& metric3_ll) const
{
    double norm = 0;
    for(int j=0; j<3; j++)
    for(int i=0; i<3; i++)
        norm += metric3_ll[{i,j}]*data[i]*data[j];
    return sqrt(abs(norm));
}
template<class Coord, class Frame>
void Tensor3<Coord,Frame>::Print(std::string name, bool newline, int precision) const
{
    std::cout << name;
    if constexpr(std::is_same<Frame,IF>::value)
    {
        std::cout << "(IF)" << " = ("
	    << Format(data[0],precision) << ","
	    << Format(data[1],precision) << ","
	    << Format(data[2],precision) << ")"
	    << std::endl;
    }
    if constexpr(std::is_same<Frame,LF>::value)
    {
        std::cout << "(LF)" << " = ("
	    << Format(data[0],precision) << ","
	    << Format(data[1],precision) << ","
	    << Format(data[2],precision) << ")"
	    << std::endl;
    }
    if(newline)
        std::cout << std::endl;
}
template<class Coord, class Frame>
double& Tensor3<Coord,Frame>::operator[](const int index)
{
    return data[index];
}
template<class Coord, class Frame>
const double& Tensor3<Coord,Frame>::operator[](const int index) const
{
    return data[index];
}
// --------------------------------------------------------



// -------------------- Simple Containers --------------------
Int2::Int2(int value)
{
    data[0] = data[1] = value;
}
Int2::Int2(int data0, int data1)
{
    data[0] = data0;
    data[1] = data1;
}
void Int2::Print(std::string name, bool newline, int precision) const
{
    std::cout << name << " = ("
	<< Format(data[0],precision) << ","
	<< Format(data[1],precision) << ")"
	<< std::endl;
    if(newline)
        std::cout << std::endl;
}
int& Int2::operator[](const int index)
{
    return data[index];
}
const int& Int2::operator[](const int index) const
{
    return data[index];
}



Int3::Int3(int value)
{
    data[0] = data[1] = data[2] = value;
}
Int3::Int3(int data0, int data1, int data2)
{
    data[0] = data0;
    data[1] = data1;
    data[2] = data2;
}
void Int3::Print(std::string name, bool newline, int precision) const
{
    std::cout << name << " = ("
	<< Format(data[0],precision) << ","
	<< Format(data[1],precision) << ","
	<< Format(data[2],precision) << ")"
	<< std::endl;
    if(newline)
        std::cout << std::endl;
}
int& Int3::operator[](const int index)
{
    return data[index];
}
const int& Int3::operator[](const int index) const
{
    return data[index];
}



Double2::Double2(double value)
{
    data[0] = data[1] = value;
}
Double2::Double2(double data0, double data1)
{
    data[0] = data0;
    data[1] = data1;
}
void Double2::Print(std::string name, bool newline, int precision) const
{
    std::cout << name << " = ("
	<< Format(data[0],precision) << ","
	<< Format(data[1],precision) << ")"
	<< std::endl;
    if(newline)
        std::cout << std::endl;
}
double& Double2::operator[](const int index)
{
    return data[index];
}
const double& Double2::operator[](const int index) const
{
    return data[index];
}



Double3::Double3(double value)
{
    data[0] = data[1] = data[2] = value;
}
Double3::Double3(double data0, double data1, double data2)
{
    data[0] = data0;
    data[1] = data1;
    data[2] = data2;
}
void Double3::Print(std::string name, bool newline, int precision) const
{
    std::cout << name << " = ("
	<< Format(data[0],precision) << ","
	<< Format(data[1],precision) << ","
	<< Format(data[2],precision) << ")"
	<< std::endl;
    if(newline)
        std::cout << std::endl;
}
double& Double3::operator[](const int index)
{
    return data[index];
}
const double& Double3::operator[](const int index) const
{
    return data[index];
}



Double4::Double4(double value)
{
    data[0] = data[1] = data[2] = data[3] = value;
}
Double4::Double4(double data0, double data1, double data2, double data3)
{
    data[0] = data0;
    data[1] = data1;
    data[2] = data2;
    data[3] = data3;
}
void Double4::Print(std::string name, bool newline, int precision) const
{
    std::cout << name << " = ("
	<< Format(data[0],precision) << ","
	<< Format(data[1],precision) << ","
	<< Format(data[2],precision) << ","
	<< Format(data[3],precision) << ")"
	<< std::endl;
    if(newline)
        std::cout << std::endl;
}
double& Double4::operator[](const int index)
{
    return data[index];
}
const double& Double4::operator[](const int index) const
{
    return data[index];
}
// -----------------------------------------------------------



// -------------------- Rank-2 Tensors --------------------
template<class Coord, class Frame>
Tensor2x2<Coord,Frame>::Tensor2x2(double value)
{
    data[0] = data[1] = data[2] = data[3] = value;
}
template<class Coord, class Frame>
Tensor2x2<Coord,Frame>::Tensor2x2
(double data11, double data12,
 double data21, double data22)
{
    data[0*2 + 0] = data11; data[0*2 + 1] = data12;
    data[1*2 + 0] = data21; data[1*2 + 1] = data22;
}
template<class Coord, class Frame>
void Tensor2x2<Coord,Frame>::Print(std::string name, bool newline, int precision) const
{
    int size = name.size();
    std::string space(size,' ');
    if constexpr(std::is_same<Frame,IF>::value)
    {
        std::cout << name  << "(IF) = (" << Format(data[0*2 + 0],precision) << "," << Format(data[0*2 + 1],precision) << ")" << std::endl;
        std::cout << space << "       (" << Format(data[1*2 + 0],precision) << "," << Format(data[1*2 + 1],precision) << ")" << std::endl;
    }
    if constexpr(std::is_same<Frame,LF>::value)
    {
        std::cout << name  << "(LF) = (" << Format(data[0*2 + 0],precision) << "," << Format(data[0*2 + 1],precision) << ")" << std::endl;
        std::cout << space << "       (" << Format(data[1*2 + 0],precision) << "," << Format(data[1*2 + 1],precision) << ")" << std::endl;
    }
    if(newline)
        std::cout << std::endl;
}
template<class Coord, class Frame>
double& Tensor2x2<Coord,Frame>::operator[](const rank2Indices& index)
{
    return data[(index.i-1)*2 + (index.j-1)];
}
template<class Coord, class Frame>
const double& Tensor2x2<Coord,Frame>::operator[](const rank2Indices& index) const
{
    return data[(index.i-1)*2 + (index.j-1)];
}
template<class Coord, class Frame>
Tensor2x2<Coord,Frame> Tensor2x2<Coord,Frame>::Invert()
{
    Tensor2x2<Coord,Frame> invers;
    using namespace Eigen;
    Map<Matrix<double,2,2,RowMajor>> matrix(data);
    Map<Matrix<double,2,2,RowMajor>> matrixInvers(invers.data);
    matrixInvers = matrix.inverse().eval();
    return invers;
}



template<class Coord, class Frame>
Tensor3x3<Coord,Frame>::Tensor3x3(double value)
{
    for(int ij=0; ij<9; ij++)
        data[ij] = value;
}
template<class Coord, class Frame>
Tensor3x3<Coord,Frame>::Tensor3x3
(double data00, double data01, double data02,
 double data10, double data11, double data12,
 double data20, double data21, double data22)
{
    data[0*3 + 0] = data00; data[0*3 + 1] = data01; data[0*3 + 2] = data02;
    data[1*3 + 0] = data10; data[1*3 + 1] = data11; data[1*3 + 2] = data12;
    data[2*3 + 0] = data20; data[2*3 + 1] = data21; data[2*3 + 2] = data22;
}
template<class Coord, class Frame>
template<class FrameB>
Tensor3x3<Coord,FrameB> Tensor3x3<Coord,Frame>::Transform(Tensor3x3<Coord,Tetrad>& tetrad) const
{
    if constexpr(std::is_same<Frame,IF>::value && std::is_same<FrameB,LF>::value)
    {// IF -> LF
        Tensor3x3<Coord,FrameB> result(0.0);
        for(int a=0; a<3; a++)
            for(int b=0; b<3; b++)
                for(int A=0; A<3; A++)
                    for(int B=0; B<3; B++)
                        result[{a,b}] += (*this)[{A,B}] * tetrad[{a,A}] * tetrad[{b,B}];
        return result;
    }
    if constexpr(std::is_same<Frame,LF>::value && std::is_same<FrameB,IF>::value)
    {// LF -> IF
        Tensor3x3<Coord,Tetrad> tetradInverse = tetrad.Invert();
        Tensor3x3<Coord,FrameB> result(0.0);
        for(int a=0; a<3; a++)
            for(int b=0; b<3; b++)
                for(int A=0; A<3; A++)
                    for(int B=0; B<3; B++)
                        result[{a,b}] += (*this)[{A,B}] * tetradInverse[{a,A}] * tetradInverse[{b,B}];
        return result;
    }
}
template<class Coord, class Frame>
template<class FrameB>
Tensor3x3<Coord,FrameB> Tensor3x3<Coord,Frame>::Transform(Tensor3x3<Coord,Tetrad>&& tetrad) const
{
    if constexpr(std::is_same<Frame,IF>::value && std::is_same<FrameB,LF>::value)
    {// IF -> LF
        Tensor3x3<Coord,FrameB> result(0.0);
        for(int a=0; a<3; a++)
            for(int b=0; b<3; b++)
                for(int A=0; A<3; A++)
                    for(int B=0; B<3; B++)
                        result[{a,b}] += (*this)[{A,B}] * tetrad[{a,A}] * tetrad[{b,B}];
        return result;
    }
    if constexpr(std::is_same<Frame,LF>::value && std::is_same<FrameB,IF>::value)
    {// LF -> IF
        Tensor3x3<Coord,Tetrad> tetradInverse = tetrad.Invert();
        Tensor3x3<Coord,FrameB> result(0.0);
        for(int a=0; a<3; a++)
            for(int b=0; b<3; b++)
                for(int A=0; A<3; A++)
                    for(int B=0; B<3; B++)
                        result[{a,b}] += (*this)[{A,B}] * tetradInverse[{a,A}] * tetradInverse[{b,B}];
        return result;
    }
}
template<class Coord, class Frame>
void Tensor3x3<Coord,Frame>::Print(std::string name, bool newline, int precision) const
{
    int size = name.size();
    std::string space(size,' ');
    if constexpr(std::is_same<Frame,IF>::value)
    {
        std::cout << space << "       (" << Format(data[0*3 + 0],precision) << "," << Format(data[0*3 + 1],precision) << "," << Format(data[0*3 + 2],precision) << ")" << std::endl;
        std::cout << name  << "(IF) = (" << Format(data[1*3 + 0],precision) << "," << Format(data[1*3 + 1],precision) << "," << Format(data[1*3 + 2],precision) << ")" << std::endl;
        std::cout << space << "       (" << Format(data[2*3 + 0],precision) << "," << Format(data[2*3 + 1],precision) << "," << Format(data[2*3 + 2],precision) << ")" << std::endl;
    }
    if constexpr(std::is_same<Frame,LF>::value)
    {
        std::cout << space << "       (" << Format(data[0*3 + 0],precision) << "," << Format(data[0*3 + 1],precision) << "," << Format(data[0*3 + 2],precision) << ")" << std::endl;
        std::cout << name  << "(LF) = (" << Format(data[1*3 + 0],precision) << "," << Format(data[1*3 + 1],precision) << "," << Format(data[1*3 + 2],precision) << ")" << std::endl;
        std::cout << space << "       (" << Format(data[2*3 + 0],precision) << "," << Format(data[2*3 + 1],precision) << "," << Format(data[2*3 + 2],precision) << ")" << std::endl;
    }
    if constexpr(std::is_same<Frame,Tetrad>::value)
    {
        std::cout << space << "   (" << Format(data[0*3 + 0],precision) << "," << Format(data[0*3 + 1],precision) << "," << Format(data[0*3 + 2],precision) << ")" << std::endl;
        std::cout << name  << " = (" << Format(data[1*3 + 0],precision) << "," << Format(data[1*3 + 1],precision) << "," << Format(data[1*3 + 2],precision) << ")" << std::endl;
        std::cout << space << "   (" << Format(data[2*3 + 0],precision) << "," << Format(data[2*3 + 1],precision) << "," << Format(data[2*3 + 2],precision) << ")" << std::endl;
    }
    if(newline)
        std::cout << std::endl;
}
template<class Coord, class Frame>
double& Tensor3x3<Coord,Frame>::operator[](const rank2Indices& index)
{
    return data[index.i*3 + index.j];
}
template<class Coord, class Frame>
const double& Tensor3x3<Coord,Frame>::operator[](const rank2Indices& index) const
{
    return data[index.i*3 + index.j];
}
template<class Coord, class Frame>
Tensor3x3<Coord,Frame> Tensor3x3<Coord,Frame>::Invert()
{
    Tensor3x3<Coord,Frame> invers;
    using namespace Eigen;
    Map<Matrix<double,3,3,RowMajor>> matrix(data);
    Map<Matrix<double,3,3,RowMajor>> matrixInvers(invers.data);
    matrixInvers = matrix.inverse().eval();
    return invers;
}
// --------------------------------------------------------



// -------------------- Rank-3 Tensors --------------------
template<class Coord, class Frame>
Tensor2x2x2<Coord,Frame>::Tensor2x2x2(double value)
{
    for(int ijk=0; ijk<8; ijk++)
        data[ijk] = value;
}
template<class Coord, class Frame>
Tensor2x2x2<Coord,Frame>::Tensor2x2x2
(double data111, double data112,
 double data121, double data122,
    double data211, double data212,
    double data221, double data222)
{
    data[0*4 + 0*2 + 0] = data111; data[0*4 + 0*2 + 1] = data112;
    data[0*4 + 1*2 + 0] = data121; data[0*4 + 1*2 + 1] = data122;
    data[1*4 + 0*2 + 0] = data211; data[1*4 + 0*2 + 1] = data212;
    data[1*4 + 1*2 + 0] = data221; data[1*4 + 1*2 + 1] = data222;
}
template<class Coord, class Frame>
void Tensor2x2x2<Coord,Frame>::Print(std::string name, bool newline, int precision) const
{
    int size = name.size();
    std::string space(size,' ');
    if constexpr(std::is_same<Frame,IF>::value)
    {
        std::cout << space << "       (" << Format(data[0*4 + 0*2 + 0],precision) << "," << Format(data[0*4 + 0*2 + 1],precision) << ")" << std::endl;
        std::cout << space << "       (" << Format(data[0*4 + 1*2 + 0],precision) << "," << Format(data[0*4 + 1*2 + 1],precision) << ")" << std::endl;
        std::cout << name  << "(IF) = (---------------------)" << std::endl;
        std::cout << space << "       (" << Format(data[1*4 + 0*2 + 0],precision) << "," << Format(data[1*4 + 0*2 + 1],precision) << ")" << std::endl;
        std::cout << space << "       (" << Format(data[1*4 + 1*2 + 0],precision) << "," << Format(data[1*4 + 1*2 + 1],precision) << ")" << std::endl;
    }
    if constexpr(std::is_same<Frame,LF>::value)
    {
        std::cout << space << "       (" << Format(data[0*4 + 0*2 + 0],precision) << "," << Format(data[0*4 + 0*2 + 1],precision) << ")" << std::endl;
        std::cout << space << "       (" << Format(data[0*4 + 1*2 + 0],precision) << "," << Format(data[0*4 + 1*2 + 1],precision) << ")" << std::endl;
        std::cout << name  << "(LF) = (---------------------)" << std::endl;
        std::cout << space << "       (" << Format(data[1*4 + 0*2 + 0],precision) << "," << Format(data[1*4 + 0*2 + 1],precision) << ")" << std::endl;
        std::cout << space << "       (" << Format(data[1*4 + 1*2 + 0],precision) << "," << Format(data[1*4 + 1*2 + 1],precision) << ")" << std::endl;
    }
    if(newline)
        std::cout << std::endl;
}
template<class Coord, class Frame>
double& Tensor2x2x2<Coord,Frame>::operator[](const rank3Indices& index)
{
    return data[(index.i-1)*4 + (index.j-1)*2 + (index.k-1)];
}
template<class Coord, class Frame>
const double& Tensor2x2x2<Coord,Frame>::operator[](const rank3Indices& index) const
{
    return data[(index.i-1)*4 + (index.j-1)*2 + (index.k-1)];
}



template<class Coord, class Frame>
Tensor3x3x3<Coord,Frame>::Tensor3x3x3(double value)
{
    for(int ijk=0; ijk<27; ijk++)
        data[ijk] = value;
}
template<class Coord, class Frame>
Tensor3x3x3<Coord,Frame>::Tensor3x3x3
(double data000, double data001, double data002,
 double data010, double data011, double data012,
 double data020, double data021, double data022,
    double data100, double data101, double data102,
    double data110, double data111, double data112,
    double data120, double data121, double data122,
        double data200, double data201, double data202,
        double data210, double data211, double data212,
        double data220, double data221, double data222)
{
    data[0*9 + 0*3 + 0] = data000; data[0*9 + 0*3 + 1] = data001; data[0*9 + 0*3 + 2] = data002;
    data[0*9 + 1*3 + 0] = data010; data[0*9 + 1*3 + 1] = data011; data[0*9 + 1*3 + 2] = data012;
    data[0*9 + 2*3 + 0] = data020; data[0*9 + 2*3 + 1] = data021; data[0*9 + 2*3 + 2] = data022;
    data[1*9 + 0*3 + 0] = data100; data[1*9 + 0*3 + 1] = data101; data[1*9 + 0*3 + 2] = data102;
    data[1*9 + 1*3 + 0] = data110; data[1*9 + 1*3 + 1] = data111; data[1*9 + 1*3 + 2] = data112;
    data[1*9 + 2*3 + 0] = data120; data[1*9 + 2*3 + 1] = data121; data[1*9 + 2*3 + 2] = data122;
    data[2*9 + 0*3 + 0] = data200; data[2*9 + 0*3 + 1] = data201; data[2*9 + 0*3 + 2] = data202;
    data[2*9 + 1*3 + 0] = data210; data[2*9 + 1*3 + 1] = data211; data[2*9 + 1*3 + 2] = data212;
    data[2*9 + 2*3 + 0] = data220; data[2*9 + 2*3 + 1] = data221; data[2*9 + 2*3 + 2] = data222;
}
template<class Coord, class Frame>
void Tensor3x3x3<Coord,Frame>::Print(std::string name, bool newline, int precision) const
{
    int size = name.size();
    std::string space(size,' ');
    if constexpr(std::is_same<Frame,IF>::value)
    {
        std::cout << space << "       (" << Format(data[0*9 + 0*3 + 0],precision) << "," << Format(data[0*9 + 0*3 + 1],precision) << "," << Format(data[0*9 + 0*3 + 2],precision) << ")" << std::endl;
        std::cout << space << "       (" << Format(data[0*9 + 1*3 + 0],precision) << "," << Format(data[0*9 + 1*3 + 1],precision) << "," << Format(data[0*9 + 1*3 + 2],precision) << ")" << std::endl;
        std::cout << space << "       (" << Format(data[0*9 + 2*3 + 0],precision) << "," << Format(data[0*9 + 2*3 + 1],precision) << "," << Format(data[0*9 + 2*3 + 2],precision) << ")" << std::endl;
        std::cout << space << "       (--------------------------------)" << std::endl;
        std::cout << space << "       (" << Format(data[1*9 + 0*3 + 0],precision) << "," << Format(data[1*9 + 0*3 + 1],precision) << "," << Format(data[1*9 + 0*3 + 2],precision) << ")" << std::endl;
        std::cout << name  << "(IF) = (" << Format(data[1*9 + 1*3 + 0],precision) << "," << Format(data[1*9 + 1*3 + 1],precision) << "," << Format(data[1*9 + 1*3 + 2],precision) << ")" << std::endl;
        std::cout << space << "       (" << Format(data[1*9 + 2*3 + 0],precision) << "," << Format(data[1*9 + 2*3 + 1],precision) << "," << Format(data[1*9 + 2*3 + 2],precision) << ")" << std::endl;
        std::cout << space << "       (--------------------------------)" << std::endl;
        std::cout << space << "       (" << Format(data[2*9 + 0*3 + 0],precision) << "," << Format(data[2*9 + 0*3 + 1],precision) << "," << Format(data[2*9 + 0*3 + 2],precision) << ")" << std::endl;
        std::cout << space << "       (" << Format(data[2*9 + 1*3 + 0],precision) << "," << Format(data[2*9 + 1*3 + 1],precision) << "," << Format(data[2*9 + 1*3 + 2],precision) << ")" << std::endl;
        std::cout << space << "       (" << Format(data[2*9 + 2*3 + 0],precision) << "," << Format(data[2*9 + 2*3 + 1],precision) << "," << Format(data[2*9 + 2*3 + 2],precision) << ")" << std::endl;
    }
    if constexpr(std::is_same<Frame,LF>::value)
    {
        std::cout << space << "       (" << Format(data[0*9 + 0*3 + 0],precision) << "," << Format(data[0*9 + 0*3 + 1],precision) << "," << Format(data[0*9 + 0*3 + 2],precision) << ")" << std::endl;
        std::cout << space << "       (" << Format(data[0*9 + 1*3 + 0],precision) << "," << Format(data[0*9 + 1*3 + 1],precision) << "," << Format(data[0*9 + 1*3 + 2],precision) << ")" << std::endl;
        std::cout << space << "       (" << Format(data[0*9 + 2*3 + 0],precision) << "," << Format(data[0*9 + 2*3 + 1],precision) << "," << Format(data[0*9 + 2*3 + 2],precision) << ")" << std::endl;
        std::cout << space << "       (--------------------------------)" << std::endl;
        std::cout << space << "       (" << Format(data[1*9 + 0*3 + 0],precision) << "," << Format(data[1*9 + 0*3 + 1],precision) << "," << Format(data[1*9 + 0*3 + 2],precision) << ")" << std::endl;
        std::cout << name  << "(LF) = (" << Format(data[1*9 + 1*3 + 0],precision) << "," << Format(data[1*9 + 1*3 + 1],precision) << "," << Format(data[1*9 + 1*3 + 2],precision) << ")" << std::endl;
        std::cout << space << "       (" << Format(data[1*9 + 2*3 + 0],precision) << "," << Format(data[1*9 + 2*3 + 1],precision) << "," << Format(data[1*9 + 2*3 + 2],precision) << ")" << std::endl;
        std::cout << space << "       (--------------------------------)" << std::endl;
        std::cout << space << "       (" << Format(data[2*9 + 0*3 + 0],precision) << "," << Format(data[2*9 + 0*3 + 1],precision) << "," << Format(data[2*9 + 0*3 + 2],precision) << ")" << std::endl;
        std::cout << space << "       (" << Format(data[2*9 + 1*3 + 0],precision) << "," << Format(data[2*9 + 1*3 + 1],precision) << "," << Format(data[2*9 + 1*3 + 2],precision) << ")" << std::endl;
        std::cout << space << "       (" << Format(data[2*9 + 2*3 + 0],precision) << "," << Format(data[2*9 + 2*3 + 1],precision) << "," << Format(data[2*9 + 2*3 + 2],precision) << ")" << std::endl;
    }
    if(newline)
        std::cout << std::endl;
}
template<class Coord, class Frame>
double& Tensor3x3x3<Coord,Frame>::operator[](const rank3Indices& index)
{
    return data[index.i*9 + index.j*3 + index.k];
}
template<class Coord, class Frame>
const double& Tensor3x3x3<Coord,Frame>::operator[](const rank3Indices& index) const
{
    return data[index.i*9 + index.j*3 + index.k];
}
// --------------------------------------------------------



template class Coordinate2<xy>;
template class Coordinate2<rph>;
template Coordinate2<xy>  Coordinate2<rph>::Transform() const;
template Coordinate2<rph> Coordinate2<xy> ::Transform() const;
template Coordinate2<xy>  Coordinate2<xy> ::Transform() const;
template Coordinate2<rph> Coordinate2<rph>::Transform() const;

template class Tensor2<xy,IF>;
template class Tensor2<rph,IF>;
template Tensor2<xy,IF>  Tensor2<rph,IF>::Transform(const Coordinate2<rph>& x12) const;
template Tensor2<rph,IF> Tensor2<xy,IF> ::Transform(const Coordinate2<xy>&  x12) const;
template Tensor2<xy,IF>  Tensor2<xy,IF> ::Transform(const Coordinate2<xy>&  x12) const;
template Tensor2<rph,IF> Tensor2<rph,IF>::Transform(const Coordinate2<rph>& x12) const;
template Tensor2<xy,IF>  Tensor2<xy,LF> ::Transform(Tensor3x3<xy,Tetrad>&  tetrad) const;
template Tensor2<rph,IF> Tensor2<rph,LF>::Transform(Tensor3x3<rph,Tetrad>& tetrad) const;
template Tensor2<xy,IF>  Tensor2<xy,LF> ::Transform(Tensor3x3<xy,Tetrad>&&  tetrad) const;
template Tensor2<rph,IF> Tensor2<rph,LF>::Transform(Tensor3x3<rph,Tetrad>&& tetrad) const;
template class Tensor2<xy,LF>;
template class Tensor2<rph,LF>;
template Tensor2<xy,LF>  Tensor2<rph,LF>::Transform(const Coordinate2<rph>& x12) const;
template Tensor2<rph,LF> Tensor2<xy,LF> ::Transform(const Coordinate2<xy>&  x12) const;
template Tensor2<xy,LF>  Tensor2<xy,LF> ::Transform(const Coordinate2<xy>&  x12) const;
template Tensor2<rph,LF> Tensor2<rph,LF>::Transform(const Coordinate2<rph>& x12) const;
template Tensor2<xy,LF>  Tensor2<xy,IF> ::Transform(Tensor3x3<xy,Tetrad>&  tetrad) const;
template Tensor2<rph,LF> Tensor2<rph,IF>::Transform(Tensor3x3<rph,Tetrad>& tetrad) const;
template Tensor2<xy,LF>  Tensor2<xy,IF> ::Transform(Tensor3x3<xy,Tetrad>&&  tetrad) const;
template Tensor2<rph,LF> Tensor2<rph,IF>::Transform(Tensor3x3<rph,Tetrad>&& tetrad) const;

template class Tensor3<xy,IF>;
template class Tensor3<rph,IF>;
template Tensor3<xy,IF>  Tensor3<rph,IF>::Transform(const Coordinate2<rph>& x12) const;
template Tensor3<rph,IF> Tensor3<xy,IF> ::Transform(const Coordinate2<xy>&  x12) const;
template Tensor3<xy,IF>  Tensor3<xy,IF> ::Transform(const Coordinate2<xy>&  x12) const;
template Tensor3<rph,IF> Tensor3<rph,IF>::Transform(const Coordinate2<rph>& x12) const;
template Tensor3<xy,IF>  Tensor3<xy,LF> ::Transform(Tensor3x3<xy,Tetrad>&  tetrad) const;
template Tensor3<rph,IF> Tensor3<rph,LF>::Transform(Tensor3x3<rph,Tetrad>& tetrad) const;
template Tensor3<xy,IF>  Tensor3<xy,LF> ::Transform(Tensor3x3<xy,Tetrad>&&  tetrad) const;
template Tensor3<rph,IF> Tensor3<rph,LF>::Transform(Tensor3x3<rph,Tetrad>&& tetrad) const;
template class Tensor3<xy,LF>;
template class Tensor3<rph,LF>;
template Tensor3<xy,LF>  Tensor3<rph,LF>::Transform(const Coordinate2<rph>& x12) const;
template Tensor3<rph,LF> Tensor3<xy,LF> ::Transform(const Coordinate2<xy>&  x12) const;
template Tensor3<xy,LF>  Tensor3<xy,LF> ::Transform(const Coordinate2<xy>&  x12) const;
template Tensor3<rph,LF> Tensor3<rph,LF>::Transform(const Coordinate2<rph>& x12) const;
template Tensor3<xy,LF>  Tensor3<xy,IF> ::Transform(Tensor3x3<xy,Tetrad>&  tetrad) const;
template Tensor3<rph,LF> Tensor3<rph,IF>::Transform(Tensor3x3<rph,Tetrad>& tetrad) const;
template Tensor3<xy,LF>  Tensor3<xy,IF> ::Transform(Tensor3x3<xy,Tetrad>&&  tetrad) const;
template Tensor3<rph,LF> Tensor3<rph,IF>::Transform(Tensor3x3<rph,Tetrad>&& tetrad) const;

template class Tensor2x2<xy,IF>;
template class Tensor2x2<xy,LF>;
template class Tensor2x2<rph,IF>;
template class Tensor2x2<rph,LF>;

template class Tensor3x3<xy,IF>;
template class Tensor3x3<xy,LF>;
template class Tensor3x3<xy,Tetrad>;
template class Tensor3x3<rph,IF>;
template class Tensor3x3<rph,LF>;
template class Tensor3x3<rph,Tetrad>;
template Tensor3x3<xy,IF>  Tensor3x3<xy,LF> ::Transform(Tensor3x3<xy,Tetrad>&  tetrad) const;
template Tensor3x3<rph,IF> Tensor3x3<rph,LF>::Transform(Tensor3x3<rph,Tetrad>& tetrad) const;
template Tensor3x3<xy,IF>  Tensor3x3<xy,LF> ::Transform(Tensor3x3<xy,Tetrad>&&  tetrad) const;
template Tensor3x3<rph,IF> Tensor3x3<rph,LF>::Transform(Tensor3x3<rph,Tetrad>&& tetrad) const;
template Tensor3x3<xy,LF>  Tensor3x3<xy,IF> ::Transform(Tensor3x3<xy,Tetrad>&  tetrad) const;
template Tensor3x3<rph,LF> Tensor3x3<rph,IF>::Transform(Tensor3x3<rph,Tetrad>& tetrad) const;
template Tensor3x3<xy,LF>  Tensor3x3<xy,IF> ::Transform(Tensor3x3<xy,Tetrad>&&  tetrad) const;
template Tensor3x3<rph,LF> Tensor3x3<rph,IF>::Transform(Tensor3x3<rph,Tetrad>&& tetrad) const;

template class Tensor2x2x2<xy,IF>;
template class Tensor2x2x2<xy,LF>;
template class Tensor2x2x2<rph,IF>;
template class Tensor2x2x2<rph,LF>;
template class Tensor3x3x3<xy,IF>;
template class Tensor3x3x3<xy,LF>;
template class Tensor3x3x3<rph,IF>;
template class Tensor3x3x3<rph,LF>;